<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Modern JavaScript Mastery - Learn JS properly from basics to advanced concepts">
  <title>Modern JavaScript Mastery</title>
  <style>
    /* (Previous CSS remains unchanged) */
  </style>
</head>
<body>
  <!-- (Previous HTML structure remains unchanged) -->

  <script>
    // ===== Revised Data: Properly organized topics =====
    const Beginner = [
      "JavaScript Fundamentals",
      "Variables: let, const (no var)",
      "Data Types: Primitives vs Objects",
      "Type Conversion & Coercion",
      "Operators: Arithmetic, Comparison, Logical",
      "Template Literals",
      "null vs undefined",
      "typeof and instanceof",
      "Functions: Declaration vs Expression",
      "Arrow Functions: Syntax and this",
      "Function Parameters & Arguments",
      "Default Parameters",
      "Rest Parameters",
      "Scope: Global, Function, Block",
      "Conditionals: if, else, switch",
      "Truthy and Falsy Values",
      "Loops: for, while, do-while",
      "break and continue",
      "Arrays: Creation and Basic Methods",
      "Array Iteration: for, for-of, forEach",
      "Objects: Literal Syntax",
      "Object Properties: Access and Modification",
      "Object Methods",
      "JSON: stringify and parse",
      "Error Handling: try/catch"
    ];

    const Intermediate = [
      "Strict Mode",
      "Equality: == vs ===, Object.is",
      "nullish coalescing (??)",
      "Optional chaining (?.)",
      "Ternary Operator",
      "Short-circuit Evaluation",
      "Array Methods: map, filter, reduce",
      "Array Methods: some, every, find",
      "Array Methods: sort, reverse",
      "Array Methods: slice, splice",
      "String Methods",
      "Spread Operator (...)",
      "Destructuring: Arrays and Objects",
      "Object.assign vs Spread",
      "Shallow vs Deep Copy",
      "Date and Time",
      "DOM Selection Methods",
      "DOM Manipulation",
      "Event Handling",
      "Event Delegation",
      "Event Object",
      "Timers: setTimeout, setInterval",
      "CSS Manipulation with JS",
      "localStorage and sessionStorage",
      "Form Handling",
      "Basic Async Concepts"
    ];

    const Advanced = [
      "Closures",
      "IIFE Pattern",
      "Higher-order Functions",
      "Function Composition",
      "Recursion",
      "this Binding Rules",
      "call, apply, bind",
      "Prototypal Inheritance",
      "ES6 Classes",
      "Class Inheritance",
      "Static Methods",
      "Private Class Fields",
      "Symbols",
      "Iterators and Iterables",
      "Generators",
      "Promises",
      "async/await",
      "Error Handling in Async Code",
      "Fetch API",
      "AbortController",
      "Web Workers",
      "Service Workers",
      "WebSockets",
      "Canvas API",
      "Proxy and Reflect",
      "Modules: import/export",
      "Dynamic Imports",
      "Performance Optimization"
    ];

    const ALL = [...Beginner, ...Intermediate, ...Advanced];

    // ===== Deep Lessons with Accurate Content =====
    const deep = {
      "Variables: let, const (no var)": {
        concept: "Modern JavaScript uses block-scoped let and const instead of function-scoped var.",
        steps: [
          "Use const by default - for values that won't be reassigned",
          "Use let when you need to reassign a variable",
          "Never use var - it has confusing function-scoping and hoisting behavior",
          "Variables declared with let/const have temporal dead zone (TDZ)"
        ],
        example: `// Good:
const PI = 3.14;
let counter = 0;

// Bad:
var oldVariable; // Don't use var`,
        practice: [
          "Create a const for your name and a let for your age",
          "Try to reassign a const and observe the error"
        ],
        quiz: [
          {
            q: "What happens if you access a let variable before declaration?",
            a: ["undefined", "ReferenceError", "null"],
            correct: 1
          },
          {
            q: "Which should you use by default?",
            a: ["let", "const", "var"],
            correct: 1
          }
        ],
        mistakes: [
          "Using var out of habit",
          "Reassigning const variables",
          "Not utilizing block scope properly"
        ]
      },
      
      "Arrow Functions: Syntax and this": {
        concept: "Arrow functions provide concise syntax and lexically bind this value.",
        steps: [
          "Syntax: (params) => expression",
          "For single parameter, parentheses are optional",
          "For single expression, return is implicit",
          "No own this - inherits from surrounding scope",
          "Cannot be used as constructors",
          "No arguments object"
        ],
        example: `// Traditional function
function add(a, b) { return a + b; }

// Arrow equivalent
const add = (a, b) => a + b;

// 'this' behavior
const obj = {
  name: 'Alice',
  traditional: function() { console.log(this.name) }, // 'Alice'
  arrow: () => console.log(this.name) // undefined (inherits window)
};`,
        practice: [
          "Convert traditional functions to arrow functions",
          "Create an object with methods using both syntaxes"
        ],
        quiz: [
          {
            q: "When should you NOT use arrow functions?",
            a: ["As object methods", "For array methods", "In setTimeout"],
            correct: 0
          },
          {
            q: "What does arrow function inherit from parent scope?",
            a: ["variables", "this", "both"],
            correct: 2
          }
        ],
        mistakes: [
          "Using arrow functions as object methods",
          "Using arrow functions as constructors",
          "Overusing arrow syntax when clarity suffers"
        ]
      },

      "Promises": {
        concept: "Promises represent eventual completion (or failure) of async operations.",
        steps: [
          "States: pending, fulfilled, rejected",
          "Create with new Promise((resolve, reject) => {...})",
          "Chain with .then() for success, .catch() for errors",
          "Use Promise.all() for multiple parallel promises",
          "Use Promise.race() for first completed promise",
          "Always handle errors with .catch()"
        ],
        example: `function fetchData(url) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => resolve(data))
      .catch(error => reject(error));
  });
}

// Usage
fetchData('https://api.example.com/data')
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));`,
        practice: [
          "Create a promise that resolves after a delay",
          "Chain multiple promises together"
        ],
        quiz: [
          {
            q: "What's the final state of a promise?",
            a: ["Pending", "Fulfilled or Rejected", "Settled"],
            correct: 1
          },
          {
            q: "How to handle multiple promises in parallel?",
            a: ["Promise.all", "Promise.race", "Promise.chain"],
            correct: 0
          }
        ],
        mistakes: [
          "Not returning promises in chain",
          "Forgetting error handling",
          "Nesting promises instead of chaining"
        ]
      },

      "async/await": {
        concept: "async/await provides syntactic sugar for working with promises.",
        steps: [
          "Mark function with async keyword",
          "Use await to pause execution until promise settles",
          "try/catch blocks for error handling",
          "Async functions always return a promise",
          "Can use await with any thenable"
        ],
        example: `async function getUserData(userId) {
  try {
    const response = await fetch(`https://api.example.com/users/${userId}`);
    if (!response.ok) {
      throw new Error('User not found');
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    throw error; // Re-throw for caller
  }
}

// Usage
(async () => {
  try {
    const user = await getUserData(123);
    console.log('User:', user);
  } catch (error) {
    // Handle error
  }
})();`,
        practice: [
          "Convert promise-based code to async/await",
          "Handle errors properly in async functions"
        ],
        quiz: [
          {
            q: "What does async function always return?",
            a: ["undefined", "Promise", "The awaited value"],
            correct: 1
          },
          {
            q: "What happens if you forget await?",
            a: ["Syntax error", "Get promise instead of value", "Nothing"],
            correct: 1
          }
        ],
        mistakes: [
          "Forgetting await keyword",
          "Not handling errors properly",
          "Using await in non-async functions"
        ]
      },

      "Modules: import/export": {
        concept: "ES Modules provide a standardized way to organize code into reusable modules.",
        steps: [
          "Use export to expose functionality",
          "Use import to use functionality from other modules",
          "Named exports vs default exports",
          "Use type='module' in script tags",
          "Modules have their own scope"
        ],
        example: `// math.js
export const PI = 3.14159;

export function sum(a, b) {
  return a + b;
}

export default function multiply(a, b) {
  return a * b;
}

// app.js
import multiply, { PI, sum } from './math.js';

console.log(PI); // 3.14159
console.log(sum(2, 3)); // 5
console.log(multiply(2, 3)); // 6`,
        practice: [
          "Create a module with utility functions",
          "Import and use the module in another file"
        ],
        quiz: [
          {
            q: "How to import a default export?",
            a: ["import { name }", "import name", "import * as name"],
            correct: 1
          },
          {
            q: "What scope do modules have?",
            a: ["Global", "Module", "Function"],
            correct: 1
          }
        ],
        mistakes: [
          "Mixing named and default imports incorrectly",
          "Forgetting type='module'",
          "Circular dependencies"
        ]
      }
    };

    // ===== Improved Template for Other Topics =====
    function templateFor(topic) {
      const level = Beginner.includes(topic) ? 'Beginner' : 
                   Intermediate.includes(topic) ? 'Intermediate' : 'Advanced';
      
      return {
        concept: `This topic covers ${topic}, an important ${level.toLowerCase()} JavaScript concept.`,
        steps: [
          `Understand the core concept of ${topic}`,
          `See practical examples of ${topic} in use`,
          `Learn common patterns and best practices`,
          `Identify and avoid common mistakes`
        ],
        example: `// Example of ${topic}
// Replace with actual implementation
function example() {
  console.log('Implement ${topic} properly');
}`,
        practice: [
          `Create a simple example using ${topic}`,
          `Identify where ${topic} would be useful in real code`
        ],
        quiz: [
          {
            q: `What is the primary purpose of ${topic}?`,
            a: ["Syntax sugar", "Solve specific problem", "Both"],
            correct: 1
          }
        ],
        mistakes: [
          "Not understanding underlying concepts",
          "Using in inappropriate situations",
          "Performance pitfalls"
        ]
      };
    }

    // ===== Rest of JavaScript Code (Remains Similar) =====
    // (Keep the existing implementation for rendering, navigation, etc.)
    // But ensure all functions are properly scoped and modernized

    // Initialize the app
    document.addEventListener('DOMContentLoaded', () => {
      renderList();
      openLesson(0);
    });
  </script>
</body>
    </html>
